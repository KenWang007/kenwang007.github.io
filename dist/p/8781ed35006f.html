<!DOCTYPE html>
<html lang="zh-CN" class="page-article">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Clawdbot 实现原理与架构说明 - 关键词: 架构, Clawdbot, 实现原理与架构说明">
    <meta name="keywords" content="架构, Clawdbot, 实现原理与架构说明">
    <meta name="author" content="Ken Wang">
    <meta name="robots" content="index, follow">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://kenwang007.github.io/dist/p/8781ed35006f.html">
    <meta property="og:title" content="Clawdbot 实现原理与架构说明 - Ken的知识库">
    <meta property="og:description" content="Clawdbot 实现原理与架构说明 - 关键词: 架构, Clawdbot, 实现原理与架构说明">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary">
    <meta property="twitter:url" content="https://kenwang007.github.io/dist/p/8781ed35006f.html">
    <meta property="twitter:title" content="Clawdbot 实现原理与架构说明 - Ken的知识库">
    <meta property="twitter:description" content="Clawdbot 实现原理与架构说明 - 关键词: 架构, Clawdbot, 实现原理与架构说明">
    
    <!-- Theme Color -->
    <meta name="theme-color" content="#6366f1">
    
    <title>Clawdbot 实现原理与架构说明 - Ken的知识库</title>
    <link rel="stylesheet" href="/style.css?v=2.1.2">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22 fill=%22%236366f1%22>📚</text></svg>">
    <link rel="canonical" href="https://kenwang007.github.io/dist/p/8781ed35006f.html">
    <link rel="manifest" href="/manifest.json">
    
    <!-- Highlight.js for code syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="Ken的知识库 RSS Feed" href="/rss.xml">
    
    <!-- Breadcrumb Navigation -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "BreadcrumbList",
      "itemListElement": [
        {
          "@type": "ListItem",
          "position": 1,
          "name": "首页",
          "item": "https://kenwang007.github.io/"
        },
        {
          "@type": "ListItem",
          "position": 2,
          "name": "Clawdbot 实现原理与架构说明",
          "item": "https://kenwang007.github.io/dist/p/8781ed35006f.html"
        }
      ]
    }
    </script>
    
    <!-- Article Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Article",
      "headline": "Clawdbot 实现原理与架构说明",
      "description": "Clawdbot 实现原理与架构说明 - 关键词: 架构, Clawdbot, 实现原理与架构说明",
      "author": {
        "@type": "Person",
        "name": "Ken Wang"
      },
      "datePublished": "2026-01-30T20:25:22.935840",
      "dateModified": "2026-01-30T20:25:22.935840",
      "inLanguage": "zh-CN"
    }
    </script>
</head>
<body>
    <!-- 星空背景 -->
    <div class="stars"></div>
    <div class="stars2"></div>
    <div class="stars3"></div>

    <!-- 顶部固定导航 -->
    <header class="top-nav">
        <div class="nav-container">
            <div class="logo">
                <a href="/index.html">
                    <span class="logo-text">📚 Ken的知识库</span>
                </a>
            </div>
            <nav class="main-nav">
                <ul id="nav-menu" class="nav-menu">
                    <!-- 动态生成的导航菜单项 -->
                </ul>
            </nav>
        </div>
    </header>

    <!-- 主内容区域 -->
    <main class="main-content">
        <!-- 左侧固定关键词索引 -->
        <aside class="keyword-sidebar">
            <div class="keyword-header">
                <h3>关键词索引</h3>
            </div>
            <div class="keyword-list" id="keyword-list">
                <!-- 动态生成的关键词 -->
            </div>
        </aside>

        <!-- 中间主内容 -->
        <section class="content-area">
            <div class="content-wrapper">
                <article class="markdown-content">
                    
<h1 id="clawdbot-实现原理与架构说明">Clawdbot 实现原理与架构说明</h1>
<h2 id="目录">📋 目录</h2>
<ol type="1">
<li><a href="#1-clawdbot-核心架构">Clawdbot 核心架构</a></li>
<li><a
href="#2-为什么能通过命令行操作本地电脑">为什么能通过命令行操作本地电脑</a></li>
<li><a href="#3-为什么需要-gateway-的存在">为什么需要 Gateway
的存在</a></li>
<li><a href="#4-调用-llm-时的隐私风险">调用 LLM 时的隐私风险</a></li>
</ol>
<hr />
<h2 id="clawdbot-核心架构">1. Clawdbot 核心架构</h2>
<h3 id="整体架构图">1.1 整体架构图</h3>
<pre><code>┌─────────────────────────────────────────────────────────────┐
│                                                      │
│   多种客户端                                         │
│   WebChat / CLI / macOS app / iOS / Android / Slack / Discord  │
│                                                      │
│              ▼                                       │
│   ┌─────────────────────────────────────┐              │
│   │         Gateway (本地服务)       │              │
│   │    ws://127.0.0.1:18789          │              │
│   │                                  │              │
│   │  ┌──────────────────────────────┐   │              │
│   │ │  AI Agent (Pi Agent)     │   │              │
│   │ │  - 接收用户指令            │   │              │
│   │ │  - 调用 LLM API              │   │              │
│   │ │  - 路由到工具调用            │   │              │
│   │ └───────────────────────────────┘   │              │
│   │                                  │              │
│   │  ┌──────────────────────────────┐   │              │
│   │ │  工具调度器               │   │              │
│   │ │  - exec (shell 命令)       │   │              │
│   │ │  - browser (浏览器控制)      │   │              │
│   │ │  - nodes (设备节点)         │   │              │
│   │ │  - canvas (画布)           │   │              │
│   │ └───────────────────────────────┘   │              │
│   │                                  │              │
│   │  ┌──────────────────────────────┐   │              │
│   │ │  系统桥接层               │   │              │
│   │ │  - macOS: AppleScript       │   │              │
│   │ │  - Linux: D-Bus             │   │              │
│   │ │  - iOS/Android: 本地 API      │   │              │
│   │ └───────────────────────────────┘   │              │
│   └─────────────────────────────────────┘   │              │
│                                                      │
└─────────────────────────────────────────────────────┘</pre>
<hr />
<h3 id="gateway-的核心组件">1.2 Gateway 的核心组件</h3>
<pre><code class="language-javascript">// Gateway (Node.js) 是一个本地运行的守护进程
const Gateway = {
  // 1. WebSocket 服务器
  server: {
    port: 18789,
    protocol: &#39;ws://&#39;
  },

  // 2. 通道管理器
  channels: {
    whatsapp: WhatsAppBot,
    telegram: TelegramBot,
    discord: DiscordBot,
    slack: SlackBot,
    imessage: BlueBubblesPlugin,
    // ...更多通道
  },

  // 3. 会话管理器
  sessions: {
    store: SQLite / Memory,
    mainSession: &#39;agent:main:main&#39;,
    reset: {
      mode: &#39;daily&#39;  // 每天重置历史
    }
  },

  // 4. 工具路由器
  tools: {
    exec: ExecTool,      // shell 命令执行
    browser: BrowserTool, // 浏览器控制
    nodes: NodesTool,     // 设备节点调用
    canvas: CanvasTool,   // 画布交互
    cron: CronTool        // 定时任务
  },

  // 5. AI Agent (Pi Agent)
  agent: {
    model: &#39;anthropic/claude-opus-4-5&#39;,
    contextWindow: 100000,
    tools: streaming
  },

  // 6. 配置管理
  config: {
    auth: {},        // 认证配置
    security: {},    // 安全策略
    agents: {}       // Agent 配置
  }
}</pre>
<hr />
<h2 id="为什么能通过命令行操作本地电脑">2.
为什么能通过命令行操作本地电脑？</h2>
<h3 id="核心原理本地运行-系统调用">2.1 核心原理：本地运行 +
系统调用</h3>
<h4 id="gateway-作为本地服务">2.1.1 Gateway 作为本地服务</h4>
<p><strong>启动方式：</strong></p>
<pre><code class="language-bash"># 方式 1: 作为系统服务（macOS）
clawdbot gateway --port 18789
# ↑ 通过 launchd 自动启动，开机自启

# 方式 2: 手动启动
clawdbot gateway --port 18789 --verbose</pre>
<p><strong>权限：</strong> - ✅ 完整的文件系统访问（读写任意文件） - ✅
shell 命令执行权限（exec 工具） - ✅ 通过 AppleScript/D-Bus 调用系统应用
- ✅ 持久化配置存储（~/.clawdbot/）</p>
<hr />
<h4 id="exec-工具的实现">2.1.2 exec 工具的实现</h4>
<pre><code class="language-bash"># exec 工具提供了什么能力

# 1. 执行任意 shell 命令
clawdbot agent --message &quot;列出当前目录的文件&quot;
# ↓ 转换为 → exec([&#39;ls&#39;, &#39;-la&#39;])

# 2. 通过 AppleScript 操作 macOS 应用
clawdbot agent --message &quot;添加日历事件&quot;
# ↓ 转换为 → exec([&#39;osascript&#39;, &#39;-e&#39;, &#39;tell application &quot;Calendar&quot; to make new event...&#39;])

# 3. 通过节点调用设备功能
clawdbot agent --message &quot;用前置摄像头拍照&quot;
# ↓ 转换为 → node.invoke(&#39;camera_snap&#39;)</pre>
<hr />
<h4 id="macos-系统调用示例">2.1.3 macOS 系统调用示例</h4>
<p><strong>AppleScript 与系统应用的通信：</strong></p>
<pre><code class="language-applescript"># 日历应用
tell application &quot;Calendar&quot;
  make new event at end of events with properties {summary:&quot;会议&quot;, start date:theDate}
end tell

# 提醒应用
tell application &quot;Reminders&quot;
  make new reminder with properties {name:&quot;午餐提醒&quot;, due date:theDate}
end tell

# 文件管理器
tell application &quot;Finder&quot;
  open folder &quot;~/Documents&quot;
end tell

# 通知系统
tell application &quot;System Events&quot;
  display notification &quot;任务完成&quot;
end tell</pre>
<p><strong>完整流程示例（添加提醒）：</strong></p>
<pre><code class="language-bash"># 步骤 1: 用户在 WebChat 中发送消息
用户: &quot;添加明天中午12点的提醒&quot;

# 步骤 2: WebChat 通过 WebSocket 发送到 Gateway
ws.send(JSON.stringify({
  type: &#39;user_message&#39;,
  content: &#39;添加明天中午12点的提醒&#39;
}))

# 步骤 3: Gateway 接收并转发给 AI Agent
gateway.on(&#39;user_message&#39;, async (data) =&gt; {
  await agent.process(data)
})

# 步骤 4: AI Agent 分析需求，决定调用工具
agent: {
  tools: {
    exec: {
      command: [&#39;osascript&#39;, &#39;-e&#39;, 
        `tell application &quot;Reminders&quot; 
         make new reminder 
         with properties {
           name:&quot;明天中午12点 - 午餐提醒&quot;, 
           due date:date &quot;2026-01-30 12:00:00&quot;
         }`]
    }
  }
}

# 步骤 5: Gateway 执行工具命令
const result = await exec(command)

# 步骤 6: 返回结果给 AI Agent
agent.receive(result)

# 步骤 7: Agent 生成回复
const response = &quot;✅ 已添加提醒到系统 Reminders&quot;

# 步骤 8: Gateway 通过 WebSocket 推送给所有客户端
ws.send(JSON.stringify({
  type: &#39;assistant_response&#39;,
  content: response
}))

# 步骤 9: WebChat 显示回复</pre>
<hr />
<h4 id="不同操作系统的调用方式">2.1.4 不同操作系统的调用方式</h4>
<table style="width:100%;">
<colgroup>
<col style="width: 16%" />
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr>
<th>操作</th>
<th>macOS 方法</th>
<th>Linux 方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>日历</td>
<td><code>osascript -e 'tell application "Calendar"'</code></td>
<td><code>dbus-send --print-reply</code></td>
<td>通过系统级 API 调用</td>
</tr>
<tr>
<td>提醒</td>
<td><code>osascript -e 'tell application "Reminders"'</code></td>
<td><code>task add</code></td>
<td>同上</td>
</tr>
<tr>
<td>文件</td>
<td><code>osascript -e 'tell application "Finder"'</code></td>
<td><code>gio open</code></td>
<td>通过文件管理器操作</td>
</tr>
<tr>
<td>浏览器</td>
<td>通过 CDP 协议控制 Chrome/Chromium</td>
<td>同左</td>
<td>远程控制浏览器</td>
</tr>
<tr>
<td>照片</td>
<td><code>camera_snap</code> 节点调用</td>
<td><code>v4l2-ctl</code></td>
<td>调用摄像头硬件</td>
</tr>
<tr>
<td>录屏</td>
<td><code>screen_record</code></td>
<td><code>ffmpeg -f x11grab</code></td>
<td>屏幕录制</td>
</tr>
<tr>
<td>通知</td>
<td><code>system_notify</code></td>
<td><code>notify-send</code></td>
<td>系统通知</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="为什么称为本地优先">2.2 为什么称为”本地优先”？</h3>
<pre><code>传统云端 AI:
┌──────────────┐
│  云端服务器  │ ◀── 你的请求 → 云端处理 → 返回结果
└──────────────┘

Clawdbot 本地优先:
┌──────────────┐
│  你的 Mac    │ ◀── 直接执行本地命令 → 无需上传数据
│  (本地运行)  │
└──────────────┘</pre>
<p><strong>本地优先的优势：</strong> - ✅
数据不离开本地设备（执行结果在本地处理） - ✅
响应速度快（本地网络调用，不经过互联网） - ✅
离线也能用（本地功能如文件操作、系统调用） - ✅
完全控制自己的数据和配置</p>
<p><strong>重要说明：</strong> - ⚠️ “本地优先”
主要体现在工具执行层（exec、file 操作） - ⚠️ LLM
调用本身仍然是云端的（除非配置本地模型）</p>
<hr />
<h3 id="实际运行示例">2.3 实际运行示例</h3>
<pre><code class="language-bash"># 启动 Gateway（作为系统服务）
clawdbot gateway --port 18789

# 查看状态
clawdbot status

# 发送消息
clawdbot message send --to +1234567890 --message &quot;你好&quot;

# 在 WebChat 中对话
# 直接访问 ws://127.0.0.1:18789/webchat

# 重启 Gateway
clawdbot gateway restart</pre>
<hr />
<h2 id="为什么需要-gateway-的存在">3. 为什么需要 Gateway 的存在？</h2>
<h3 id="没有-gateway-的问题">3.1 没有 Gateway 的问题</h3>
<h4 id="场景每个客户端独立连接">场景：每个客户端独立连接</h4>
<pre><code>客户端 A (WebChat) ─┐
                    ├─ 直接连接 WhatsApp
客户端 B (macOS app) ├─ 直接连接 Telegram  
客户端 C (CLI)     ├─ 直接连接 Slack
客户端 D (iOS node) ─┘   ├─ 直接调用 macOS API
                          └─ 直接运行 shell 命令</pre>
<p><strong>存在的问题：</strong></p>
<ul>
<li>❌
<strong>代码重复</strong>：每个客户端都要实现相同的功能（消息收发、状态管理）</li>
<li>❌ <strong>状态不统一</strong>：CLI 发送的消息，macOS app
看不到</li>
<li>❌
<strong>工具分散</strong>：每个客户端都要实现自己的浏览器控制、文件操作</li>
<li>❌
<strong>安全风险</strong>：多个端点连接同一服务，权限控制困难</li>
<li>❌ <strong>资源浪费</strong>：每个客户端都要维护 AI Agent
运行时</li>
<li>❌ <strong>功能不一致</strong>：不同客户端的功能可能有差异</li>
</ul>
<hr />
<h3 id="gateway-解决的核心问题">3.2 Gateway 解决的核心问题</h3>
<h4 id="统一控制平面">3.2.1 统一控制平面</h4>
<pre><code>┌─────────────────────────────────────┐
│          Gateway                │
│    ws://127.0.0.1:18789          │
│                                 │
│  ┌────────────────────────┐        │
│  │  通道管理器         │        │
│  │ - 连接/断开         │        │
│  │ - 重连逻辑         │        │
│  │ - 消息队列         │        │
│  └────────────────────────┘        │
│                                 │
│  ┌────────────────────────┐        │
│  │  会话管理器         │        │
│  │ - 上下文保持         │        │
│  │ - 历史记录         │        │
│  │ - 多端同步         │        │
│  └────────────────────────┘        │
│                                 │
│  ┌────────────────────────┐        │
│  │  工具路由器         │        │
│  │ - exec、browser      │        │
│  │ - canvas、nodes      │        │
│  └────────────────────────┘        │
│                                 │
│  ┌────────────────────────┐        │
│  │  AI Agent (Pi)       │        │
│  │ - 模型调用           │        │
│  │ - 工具流式传输       │        │
│  └────────────────────────┘        │
└─────────────────────────────────────┘</pre>
<hr />
<h4 id="客户端简化为傻瓜终端">3.2.2 客户端简化为”傻瓜终端”</h4>
<pre><code class="language-javascript">// 所有客户端只需要做一件事：连接 Gateway
class WebChat {
  constructor() {
    this.ws = new WebSocket(&#39;ws://127.0.0.1:18789/webchat&#39;)
  }  
  
  send(message) {
    this.ws.send(JSON.stringify({ type: &#39;user_message&#39;, content: message }))
  }  
  
  onMessage(data) {
    display(data.assistant_response)  // 直接显示
  }
}

class CLI {
  async main(message) {
    const ws = await connect(&#39;ws://127.0.0.1:18789&#39;)
    ws.send({ type: &#39;user_message&#39;, content: message })
    
    for await (const data of ws.on(&#39;message&#39;)) {
      if (data.type === &#39;assistant_response&#39;) {
        console.log(data.content)
        break
      }
    }
  }
}</pre>
<p><strong>客户端的优势：</strong> - ✅
<strong>极简客户端</strong>：只需要 WebSocket + UI - ✅
<strong>功能一致</strong>：所有端享受相同的功能 - ✅
<strong>自动更新</strong>：Gateway 更新，所有客户端自动受益</p>
<hr />
<h4 id="会话统一和共享">3.2.3 会话统一和共享</h4>
<pre><code class="language-javascript">// Gateway 统一管理会话状态
Gateway 的会话管理器：
┌─────────────────────────────────────┐
│  Session State                   │
│  ┌─────────────────────────┐       │
│  │  agent:main:main      │       │
│  │ - 上下文: [过去消息]  │       │
│  │ - 用户偏好           │       │
│  │ - 工具权限           │       │
│  └─────────────────────────┘       │
│                                 │
│  多个客户端可以接入同一会话：       │
│  • WebChat                    │
│  • macOS menu bar             │
│  • CLI (继续对话)             │
└─────────────────────────────────────┘</pre>
<p><strong>没有 Gateway：</strong> - ❌ WebChat 的对话和 macOS app
完全独立 - ❌ CLI 无法继续之前的对话</p>
<p><strong>有 Gateway：</strong> - ✅ 切换设备无缝继续同一对话 - ✅
统一的上下文和记忆</p>
<hr />
<h4 id="安全和权限集中管理">3.2.4 安全和权限集中管理</h4>
<pre><code class="language-javascript">// Gateway 中处理所有安全问题
Gateway 安全层：
┌─────────────────────────────────────┐
│  认证管理器                       │
│  - OAuth token 管理                │
│  - API key 轮询和降级            │
│  - 模型故障转移                 │
│                                  │
│  权限控制器                       │
│  - channel.allowFrom (白名单)        │
│  - dmPolicy (私信策略)            │
│  - sandbox.mode (沙箱隔离)         │
│                                  │
│  审计日志                          │
│  - 所有工具调用记录                │
│  - 敏感操作追踪                 │
└─────────────────────────────────────┘</pre>
<p><strong>没有 Gateway：</strong> - ❌ 每个客户端都要实现自己的安全逻辑
- ❌ 权限策略分散，难以统一管理 - ❌
容易出现安全漏洞（某个客户端漏了）</p>
<hr />
<h4 id="工具系统的统一调度">3.2.5 工具系统的统一调度</h4>
<pre><code class="language-javascript">// Gateway 作为工具调度中心
工具调用流程：

1. AI Agent 分析需要什么工具
2. Agent 向 Gateway 请求：{ tool: &#39;exec&#39;, args: [...] }
3. Gateway 检查权限和安全
4. Gateway 路由到正确的执行器
5. Gateway 返回结果给 Agent
6. Agent 根据结果继续思考

示例流程：
┌─────────────────────────────────────┐
│          Gateway                │
│                                 │
│  Agent 请求：                    │
│  &quot;帮我打开浏览器查 GitHub&quot;       │
│        ↓                        │
│  Gateway 路由：                  │
│  ┌─────────────────────────┐     │
│  │  browser.open → CDP    │     │
│  │  snapshot              │     │
│  │  act → navigate        │     │
│  └─────────────────────────┘     │
│        ↓                        │
│  返回给 Agent：                    │
│  &quot;已打开 GitHub，页面内容如下...&quot; │
└─────────────────────────────────────┘</pre>
<p><strong>没有 Gateway：</strong> - ❌
每个客户端都要实现完整的浏览器控制 - ❌ 重复造轮子</p>
<hr />
<h3 id="总结gateway-的核心价值">3.3 总结：Gateway 的核心价值</h3>
<table>
<thead>
<tr>
<th>维度</th>
<th>无 Gateway</th>
<th>有 Gateway</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>开发复杂度</strong></td>
<td>每个端点独立实现</td>
<td>集中实现一次</td>
</tr>
<tr>
<td><strong>代码重复</strong></td>
<td>大量重复逻辑</td>
<td>DRY 原则</td>
</tr>
<tr>
<td><strong>会话同步</strong></td>
<td>完全独立</td>
<td>多端共享</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>分散管理</td>
<td>统一控制</td>
</tr>
<tr>
<td><strong>维护成本</strong></td>
<td>需同时维护 N 个客户端</td>
<td>只维护 Gateway</td>
</tr>
<tr>
<td><strong>功能一致性</strong></td>
<td>很难保证</td>
<td>天然保证</td>
</tr>
<tr>
<td><strong>扩展性</strong></td>
<td>每个端都要改</td>
<td>部署 Gateway 即可</td>
</tr>
<tr>
<td><strong>新功能</strong></td>
<td>每个端都要适配</td>
<td>一次接入</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="调用-llm-时的隐私风险">4. 调用 LLM 时的隐私风险</h2>
<h3 id="数据流向分析">4.1 数据流向分析</h3>
<pre><code>本地设备                          云端 LLM API
     │                                    │
     ├─ 用户消息 ───────────────────────┤
     ├─ 对话历史 ───────────────────────┤
     ├─ 系统提示词 ───────────────────────┤
     └─ 工具执行结果 ───────────────────┤</pre>
<p><strong>这些内容都会通过 HTTPS 发送到 OpenAI/Anthropic 等云端
API。</strong></p>
<hr />
<h3 id="到底会泄漏什么">4.2 到底会泄漏什么？</h3>
<h4 id="对话历史最大的风险">4.2.1 对话历史（最大的风险）</h4>
<pre><code class="language-javascript">// Gateway 会话管理器发送给 LLM 的内容
{
  &quot;messages&quot;: [
    { &quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;帮我修改 /etc/hosts&quot; },
    { &quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;好的，已执行...&quot; },
    { &quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;还有昨天我们讨论的机密计划&quot; }
  ]
}</pre>
<p><strong>风险：</strong> - 所有对话历史都会发送到云端 -
包括之前讨论的敏感信息 - 即使你”忘记”了，云端 API 记录可能还在</p>
<hr />
<h4 id="系统提示词">4.2.2 系统提示词</h4>
<pre><code class="language-javascript">// AGENTS.md、SOUL.md、TOOLS.md 等文件内容
const systemPrompt = loadFile(&#39;AGENTS.md&#39;) + loadFile(&#39;SOUL.md&#39;)</pre>
<p><strong>风险：</strong> - 所有注入到 Agent 的配置都会发送给 LLM -
包括你定义的工作空间、偏好设置等</p>
<hr />
<h4 id="工具执行结果">4.2.3 工具执行结果</h4>
<pre><code class="language-javascript">// Agent 调用 exec 读取文件后
const toolResult = exec(&#39;cat /Users/jianwang/secret.txt&#39;)
// 这个结果会被发送回 LLM 用于上下文</pre>
<p><strong>风险：</strong> - 如果 Agent 读取了敏感文件，内容会出现在 LLM
的上下文中 - 即使文件本身不直接发送，但读取后的”记忆”会持续存在</p>
<hr />
<h3 id="clawdbot-的安全措施">4.3 Clawdbot 的安全措施</h3>
<p>尽管有风险，Clawdbot <strong>确实实现了多项安全机制</strong>：</p>
<h4 id="配置层面的控制">4.3.1 配置层面的控制</h4>
<pre><code class="language-json">{
  &quot;agents&quot;: {
    &quot;defaults&quot;: {
      &quot;contextTokens&quot;: 100000,  // 限制上下文大小
      &quot;session&quot;: {
        &quot;reset&quot;: {
          &quot;mode&quot;: &quot;daily&quot;  // 每天重置会话，旧历史不会累积
        }
      },
      &quot;memorySearch&quot;: {
        &quot;enabled&quot;: true  // 本地记忆搜索，不用每次重传
      }
    }
  }
}</pre>
<hr />
<h4 id="模型提供商选择">4.3.2 模型提供商选择</h4>
<pre><code class="language-bash"># 可以选择不同提供商
anthropic/claude-opus-4-5      # Anthropic 承诺不训练数据
openai/gpt-4                  # OpenAI 的隐私政策
zai/glm-4.7                    # 可能是本地/中国模型</pre>
<hr />
<h4 id="本地模型选项">4.3.3 本地模型选项</h4>
<pre><code class="language-json">{
  &quot;models&quot;: {
    &quot;providers&quot;: {
      &quot;ollama&quot;: {  // 本地 LLM，数据不离开设备
        &quot;baseUrl&quot;: &quot;http://localhost:11434&quot;,
        &quot;apiKey&quot;: &quot;local&quot;
      }
    }
  }
}</pre>
<hr />
<h4 id="工具权限控制">4.3.4 工具权限控制</h4>
<pre><code class="language-json">{
  &quot;tools&quot;: {
    &quot;exec&quot;: {
      &quot;ask&quot;: &quot;on-miss&quot;  // 敏感命令需要确认
      &quot;safeBins&quot;: [&quot;ls&quot;, &quot;date&quot;]  // 安全命令白名单
    }
  }
}</pre>
<hr />
<h4 id="沙箱隔离">4.3.5 沙箱隔离</h4>
<pre><code class="language-json">{
  &quot;agents&quot;: {
    &quot;defaults&quot;: {
      &quot;sandbox&quot;: {
        &quot;mode&quot;: &quot;non-main&quot;  // 非 main 会话在 Docker 沙箱中运行
      }
    }
  }
}</pre>
<hr />
<h3 id="实际风险对比">4.4 实际风险对比</h3>
<table>
<thead>
<tr>
<th>风险类型</th>
<th>传统云端 ChatGPT</th>
<th>Clawdbot</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>对话历史</td>
<td>✅ 全部上传</td>
<td>✅ 全部上传</td>
<td>风险相同</td>
</tr>
<tr>
<td>工具执行结果</td>
<td>❌ 没有</td>
<td>⚠️ 会上传</td>
<td>Clawdbot 特有风险</td>
</tr>
<tr>
<td>本地文件系统</td>
<td>❌ 无法访问</td>
<td>⚠️ Agent 可读取</td>
<td>Clawdbot 特有风险</td>
</tr>
<tr>
<td>系统配置</td>
<td>❌ 不涉及</td>
<td>⚠️ 会注入到 prompt</td>
<td>Clawdbot 特有风险</td>
</tr>
<tr>
<td>数据离开设备</td>
<td>✅ 全部</td>
<td>⚠️ 部分上传</td>
<td>Clawdbot 本地操作部分不上传</td>
</tr>
</tbody>
</table>
<p><strong>关键点：</strong> - <strong>Clawdbot
的”本地优先”主要体现在工具执行（exec、file），不体现在 LLM
调用上</strong> - <strong>LLM
调用本身仍然是云端的</strong>（除非使用本地模型如 Ollama）</p>
<hr />
<h3 id="网络传输安全">4.5 网络传输安全</h3>
<pre><code class="language-plaintext">你的设备                     ISP                   LLM API 服务器
     │                              │                    │
     │ ┌────────────────┐        │                    │
     │ │ HTTPS 加密    │        │                    │
     │ └────────────────┘        │                    │
     │                              │                    │
     ▼                              ▼                    │
    TLS 1.3 加密传输                │</pre>
<p><strong>安全的部分：</strong> - ✅ 传输使用 TLS 1.3 加密 - ✅
中间人无法看到内容 - ✅ 大多数 reputable API 提供商有严格的隐私政策</p>
<p><strong>可能暴露的：</strong> - ⚠️ <strong>元数据</strong>：IP
地址、请求时间、API 端点 - ⚠️
<strong>使用模式</strong>：请求频率、大致使用量 - ⚠️
<strong>模型提供商</strong>：知道你在使用哪个服务</p>
<hr />
<h3 id="如何最大程度降低风险">4.6 如何最大程度降低风险？</h3>
<h4 id="使用本地模型最佳">4.6.1 使用本地模型（最佳）</h4>
<pre><code class="language-bash"># 配置本地 Ollama
clawdbot config set models.providers.ollama.baseUrl http://localhost:11434
clawdbot config set models.providers.ollama.apiKey local

# 之后所有对话都在本地完成</pre>
<hr />
<h4 id="敏感信息不要写在对话中">4.6.2 敏感信息不要写在对话中</h4>
<pre><code class="language-javascript">// ❌ 不推荐
&quot;我的密码是 abc123，帮我登录&quot;

// ✅ 推荐（通过本地工具）
&quot;请在本地输入密码&quot;</pre>
<hr />
<h4 id="定期重置会话">4.6.3 定期重置会话</h4>
<pre><code class="language-bash">clawdbot config set agents.defaults.session.reset.mode daily
# 每天清除历史，旧对话不会持续发送</pre>
<hr />
<h4 id="禁用某些工具">4.6.4 禁用某些工具</h4>
<pre><code class="language-json">{
  &quot;tools&quot;: {
    &quot;deny&quot;: [&quot;exec&quot;, &quot;read&quot;]  // 禁止文件操作
  }
}</pre>
<hr />
<h4 id="选择隐私优先的提供商">4.6.5 选择隐私优先的提供商</h4>
<pre><code class="language-bash"># Anthropic 承诺不使用客户数据训练
clawdbot config set agent.model anthropic/claude-opus-4-5</pre>
<hr />
<h2 id="总结">总结</h2>
<h3 id="关键认知">5.1 关键认知</h3>
<ul>
<li>❌ <strong>“本地优先”≠ “完全离线”</strong></li>
<li>❌ <strong>“本地运行”≠ “数据不离开设备”</strong></li>
<li>✅ <strong>真正的本地安全只有：本地
LLM（Ollama/Llamafile）</strong></li>
</ul>
<h3 id="clawdbot-的价值">5.2 Clawdbot 的价值</h3>
<p><strong>Clawdbot 的价值在于给了你选择权：</strong> - ✅
你可以用云端模型（更快、更强） - ✅ 也可以用本地模型（完全私密） - ✅
根据场景选择合适的模式</p>
<p><strong>这是权衡，不是完美的解决方案。🔐</strong></p>
<hr />
<h2 id="附录快速参考">附录：快速参考</h2>
<h3 id="常用命令">常用命令</h3>
<pre><code class="language-bash"># Gateway 管理
clawdbot gateway start     # 启动 Gateway
clawdbot gateway stop      # 停止 Gateway
clawdbot gateway restart   # 重启 Gateway
clawdbot status           # 查看状态

# 发送消息
clawdbot message send --to &lt;目标&gt; --message &quot;内容&quot;

# 配置
clawdbot config get &lt;路径&gt;     # 获取配置
clawdbot config set &lt;路径&gt; &lt;值&gt; # 设置配置
clawdbot config list           # 列出配置

# 调试
clawdbot doctor              # 诊断问题</pre>
<h3 id="配置文件路径">配置文件路径</h3>
<pre><code class="language-bash"># 主配置文件
~/.clawdbot/clawdbot.json

# 工作区（默认）
~/clawd/

# 工作区 AGENTS.md
~/clawd/AGENTS.md

# 工作区 SOUL.md
~/clawd/SOUL.md

# 会话存储
~/.clawdbot/sessions/</pre>
<h3 id="安全建议">安全建议</h3>
<ol type="1">
<li>✅ 使用本地模型处理敏感信息</li>
<li>✅ 定期清理会话历史（daily reset）</li>
<li>✅ 不要在对话中讨论敏感话题（如使用云端模型）</li>
<li>✅ 禁用不需要的文件操作工具</li>
<li>✅ 选择隐私优先的 LLM 提供商</li>
<li>✅ 了解并接受这是云端 AI 的固有特性</li>
</ol>
<hr />
<p><strong>文档版本：</strong> v1.0<br />
<strong>最后更新：</strong> 2026-01-29<br />
<strong>作者：</strong> Clawdbot 社区贡献</p>

                </article>
            </div>
        </section>

        <!-- 右侧热门文章 -->
        <aside class="popular-sidebar">
            <div class="popular-header">
                <h3>热门文章</h3>
            </div>
            <div class="popular-list" id="popular-list">
                <!-- 动态生成的热门文章列表 -->
            </div>
        </aside>
    </main>

    <!-- JavaScript -->
    <script type="module" src="/script.js?v=2.2.0"></script>
    
    <!-- Initialize Highlight.js -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Highlight all code blocks
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
            });
        });
    </script>
</body>
</html>