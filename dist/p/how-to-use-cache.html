<!DOCTYPE html>
<html lang="zh-CN" class="page-article">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="ğŸ’¾ è½¯ä»¶æ¶æ„ä¸­çš„ç¼“å­˜è®¾è®¡å…¨è§£æ - å…³é”®è¯: æ¶æ„, è½¯ä»¶æ¶æ„ä¸­çš„ç¼“å­˜è®¾è®¡å…¨è§£æ">
    <meta name="keywords" content="æ¶æ„, è½¯ä»¶æ¶æ„ä¸­çš„ç¼“å­˜è®¾è®¡å…¨è§£æ">
    <meta name="author" content="Ken Wang">
    <meta name="robots" content="index, follow">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://kenwang007.github.io/dist/p/how-to-use-cache.html">
    <meta property="og:title" content="ğŸ’¾ è½¯ä»¶æ¶æ„ä¸­çš„ç¼“å­˜è®¾è®¡å…¨è§£æ - Kençš„çŸ¥è¯†åº“">
    <meta property="og:description" content="ğŸ’¾ è½¯ä»¶æ¶æ„ä¸­çš„ç¼“å­˜è®¾è®¡å…¨è§£æ - å…³é”®è¯: æ¶æ„, è½¯ä»¶æ¶æ„ä¸­çš„ç¼“å­˜è®¾è®¡å…¨è§£æ">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary">
    <meta property="twitter:url" content="https://kenwang007.github.io/dist/p/how-to-use-cache.html">
    <meta property="twitter:title" content="ğŸ’¾ è½¯ä»¶æ¶æ„ä¸­çš„ç¼“å­˜è®¾è®¡å…¨è§£æ - Kençš„çŸ¥è¯†åº“">
    <meta property="twitter:description" content="ğŸ’¾ è½¯ä»¶æ¶æ„ä¸­çš„ç¼“å­˜è®¾è®¡å…¨è§£æ - å…³é”®è¯: æ¶æ„, è½¯ä»¶æ¶æ„ä¸­çš„ç¼“å­˜è®¾è®¡å…¨è§£æ">
    
    <!-- Theme Color -->
    <meta name="theme-color" content="#6366f1">
    
    <title>ğŸ’¾ è½¯ä»¶æ¶æ„ä¸­çš„ç¼“å­˜è®¾è®¡å…¨è§£æ - Kençš„çŸ¥è¯†åº“</title>
    <link rel="stylesheet" href="/style.css?v=2.1.2">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22 fill=%22%236366f1%22>ğŸ“š</text></svg>">
    <link rel="canonical" href="https://kenwang007.github.io/dist/p/how-to-use-cache.html">
    <link rel="manifest" href="/manifest.json">
    
    <!-- Highlight.js for code syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="Kençš„çŸ¥è¯†åº“ RSS Feed" href="/rss.xml">
    
    <!-- Breadcrumb Navigation -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "BreadcrumbList",
      "itemListElement": [
        {
          "@type": "ListItem",
          "position": 1,
          "name": "é¦–é¡µ",
          "item": "https://kenwang007.github.io/"
        },
        {
          "@type": "ListItem",
          "position": 2,
          "name": "ğŸ’¾ è½¯ä»¶æ¶æ„ä¸­çš„ç¼“å­˜è®¾è®¡å…¨è§£æ",
          "item": "https://kenwang007.github.io/dist/p/how-to-use-cache.html"
        }
      ]
    }
    </script>
    
    <!-- Article Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Article",
      "headline": "ğŸ’¾ è½¯ä»¶æ¶æ„ä¸­çš„ç¼“å­˜è®¾è®¡å…¨è§£æ",
      "description": "ğŸ’¾ è½¯ä»¶æ¶æ„ä¸­çš„ç¼“å­˜è®¾è®¡å…¨è§£æ - å…³é”®è¯: æ¶æ„, è½¯ä»¶æ¶æ„ä¸­çš„ç¼“å­˜è®¾è®¡å…¨è§£æ",
      "author": {
        "@type": "Person",
        "name": "Ken Wang"
      },
      "datePublished": "2026-01-29T20:26:18.620163",
      "dateModified": "2026-01-29T20:26:18.620163",
      "inLanguage": "zh-CN"
    }
    </script>
</head>
<body>
    <!-- æ˜Ÿç©ºèƒŒæ™¯ -->
    <div class="stars"></div>
    <div class="stars2"></div>
    <div class="stars3"></div>

    <!-- é¡¶éƒ¨å›ºå®šå¯¼èˆª -->
    <header class="top-nav">
        <div class="nav-container">
            <div class="logo">
                <a href="/index.html">
                    <span class="logo-text">ğŸ“š Kençš„çŸ¥è¯†åº“</span>
                </a>
            </div>
            <nav class="main-nav">
                <ul id="nav-menu" class="nav-menu">
                    <!-- åŠ¨æ€ç”Ÿæˆçš„å¯¼èˆªèœå•é¡¹ -->
                </ul>
            </nav>
        </div>
    </header>

    <!-- ä¸»å†…å®¹åŒºåŸŸ -->
    <main class="main-content">
        <!-- å·¦ä¾§å›ºå®šå…³é”®è¯ç´¢å¼• -->
        <aside class="keyword-sidebar">
            <div class="keyword-header">
                <h3>å…³é”®è¯ç´¢å¼•</h3>
            </div>
            <div class="keyword-list" id="keyword-list">
                <!-- åŠ¨æ€ç”Ÿæˆçš„å…³é”®è¯ -->
            </div>
        </aside>

        <!-- ä¸­é—´ä¸»å†…å®¹ -->
        <section class="content-area">
            <div class="content-wrapper">
                <article class="markdown-content">
                    
<h1 id="è½¯ä»¶æ¶æ„ä¸­çš„ç¼“å­˜è®¾è®¡å…¨è§£æ">ğŸ’¾ è½¯ä»¶æ¶æ„ä¸­çš„ç¼“å­˜è®¾è®¡å…¨è§£æ</h1>
<blockquote>
<p>â€œThere are only two hard things in Computer Science: cache
invalidation and naming things.â€ â€” Phil Karlton</p>
</blockquote>
<h2 id="ç¼“å­˜æ¦‚è¿°">1. ç¼“å­˜æ¦‚è¿°</h2>
<h3 id="ä»€ä¹ˆæ˜¯ç¼“å­˜">1.1 ä»€ä¹ˆæ˜¯ç¼“å­˜ï¼Ÿ</h3>
<p><strong>ç¼“å­˜ï¼ˆCacheï¼‰</strong>
æ˜¯ä¸€ç§å°†æ•°æ®å­˜å‚¨åœ¨æ›´å¿«è®¿é—®å±‚çš„æŠ€æœ¯ï¼Œç”¨äºå‡å°‘æ•°æ®è®¿é—®å»¶è¿Ÿã€é™ä½åç«¯è´Ÿè½½ã€æå‡ç³»ç»Ÿååé‡ã€‚</p>
<pre><code>ç¼“å­˜ = ç”¨ç©ºé—´æ¢æ—¶é—´

CPU å¯„å­˜å™¨ (~1ns) â†’ å†…å­˜ (~100ns) â†’ ç£ç›˜ (~100Î¼s)
è®¿é—®é€Ÿåº¦å·®å¼‚å¯è¾¾ 10ä¸‡å€ï¼</pre>
<h3 id="å¤šçº§ç¼“å­˜æ¶æ„">1.2 å¤šçº§ç¼“å­˜æ¶æ„</h3>
<pre><code>å®¢æˆ·ç«¯ â†’ CDN â†’ ç½‘å…³å±‚ â†’ åº”ç”¨å±‚ â†’ åˆ†å¸ƒå¼ç¼“å­˜(Redis) â†’ æœ¬åœ°ç¼“å­˜ â†’ æ•°æ®åº“</pre>
<h3 id="net-ç¼“å­˜æŠ€æœ¯æ ˆ">1.3 .NET ç¼“å­˜æŠ€æœ¯æ ˆ</h3>
<table>
<thead>
<tr>
<th>å±‚çº§</th>
<th>æŠ€æœ¯æ–¹æ¡ˆ</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>æœ¬åœ°ç¼“å­˜</strong></td>
<td><code>IMemoryCache</code>ã€<code>LazyCache</code></td>
</tr>
<tr>
<td><strong>åˆ†å¸ƒå¼ç¼“å­˜</strong></td>
<td><code>IDistributedCache</code>ã€<code>StackExchange.Redis</code></td>
</tr>
<tr>
<td><strong>ç¼“å­˜æŠ½è±¡</strong></td>
<td><code>Microsoft.Extensions.Caching</code></td>
</tr>
<tr>
<td><strong>æ··åˆç¼“å­˜</strong></td>
<td><code>HybridCache</code>ï¼ˆ.NET 9ï¼‰ã€<code>FusionCache</code></td>
</tr>
</tbody>
</table>
<hr />
<h2 id="å¸¸è§ç¼“å­˜é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ">2. å¸¸è§ç¼“å­˜é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ</h2>
<h3 id="ç¼“å­˜ç©¿é€-cache-penetration">2.1 ç¼“å­˜ç©¿é€ (Cache
Penetration)</h3>
<p><strong>é—®é¢˜</strong>ï¼šæŸ¥è¯¢ä¸å­˜åœ¨çš„æ•°æ®ï¼Œç¼“å­˜æ°¸è¿œæ— æ³•å‘½ä¸­ï¼Œè¯·æ±‚ç›´æ¥æ‰“åˆ°æ•°æ®åº“ã€‚</p>
<h4 id="è§£å†³æ–¹æ¡ˆä¸€ç¼“å­˜ç©ºå¯¹è±¡">è§£å†³æ–¹æ¡ˆä¸€ï¼šç¼“å­˜ç©ºå¯¹è±¡</h4>
<pre><code class="language-csharp">public class UserService
{
    private readonly IDistributedCache _cache;
    private readonly IUserRepository _repository;
    
    public async Task&lt;User?&gt; GetUserAsync(int userId)
    {
        var cacheKey = $&quot;user:{userId}&quot;;
        var cached = await _cache.GetStringAsync(cacheKey);
        
        if (cached != null)
        {
            // ç©ºå¯¹è±¡æ ‡è®°
            return cached == &quot;NULL&quot; ? null : JsonSerializer.Deserialize&lt;User&gt;(cached);
        }
        
        var user = await _repository.GetByIdAsync(userId);
        
        if (user != null)
        {
            await _cache.SetStringAsync(cacheKey, JsonSerializer.Serialize(user),
                new DistributedCacheEntryOptions { AbsoluteExpirationRelativeToNow = TimeSpan.FromHours(1) });
        }
        else
        {
            // ç¼“å­˜ç©ºå¯¹è±¡ï¼ŒçŸ­è¿‡æœŸæ—¶é—´
            await _cache.SetStringAsync(cacheKey, &quot;NULL&quot;,
                new DistributedCacheEntryOptions { AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(5) });
        }
        
        return user;
    }
}</pre>
<h4 id="è§£å†³æ–¹æ¡ˆäºŒå¸ƒéš†è¿‡æ»¤å™¨">è§£å†³æ–¹æ¡ˆäºŒï¼šå¸ƒéš†è¿‡æ»¤å™¨</h4>
<pre><code class="language-csharp">// ä½¿ç”¨ BloomFilter.NetCore åŒ…
public class UserServiceWithBloom
{
    private readonly Filter&lt;int&gt; _bloomFilter;
    private readonly IDistributedCache _cache;
    
    public UserServiceWithBloom()
    {
        // åˆå§‹åŒ–å¸ƒéš†è¿‡æ»¤å™¨ï¼Œé¢„åŠ è½½æ‰€æœ‰æœ‰æ•ˆID
        _bloomFilter = FilterBuilder.Build&lt;int&gt;(10000000, 0.001);
    }
    
    public async Task&lt;User?&gt; GetUserAsync(int userId)
    {
        // å¸ƒéš†è¿‡æ»¤å™¨æ£€æŸ¥ï¼šä¸å­˜åœ¨åˆ™ä¸€å®šä¸å­˜åœ¨
        if (!_bloomFilter.Contains(userId))
            return null;
        
        // å¯èƒ½å­˜åœ¨ï¼Œç»§ç»­æŸ¥è¯¢ç¼“å­˜å’Œæ•°æ®åº“...
        return await GetFromCacheOrDbAsync(userId);
    }
}</pre>
<h3 id="ç¼“å­˜å‡»ç©¿-cache-breakdown">2.2 ç¼“å­˜å‡»ç©¿ (Cache Breakdown)</h3>
<p><strong>é—®é¢˜</strong>ï¼šçƒ­ç‚¹ Key
çªç„¶è¿‡æœŸï¼Œå¤§é‡å¹¶å‘è¯·æ±‚ç›´æ¥æ‰“åˆ°æ•°æ®åº“ã€‚</p>
<h4 id="è§£å†³æ–¹æ¡ˆä¸€åˆ†å¸ƒå¼é”">è§£å†³æ–¹æ¡ˆä¸€ï¼šåˆ†å¸ƒå¼é”</h4>
<pre><code class="language-csharp">public class HotDataService
{
    private readonly IDistributedCache _cache;
    private readonly IConnectionMultiplexer _redis;
    
    public async Task&lt;Product?&gt; GetHotProductAsync(int productId)
    {
        var cacheKey = $&quot;product:{productId}&quot;;
        var cached = await _cache.GetStringAsync(cacheKey);
        
        if (cached != null)
            return JsonSerializer.Deserialize&lt;Product&gt;(cached);
        
        var lockKey = $&quot;lock:{cacheKey}&quot;;
        var db = _redis.GetDatabase();
        
        // å°è¯•è·å–åˆ†å¸ƒå¼é”
        if (await db.StringSetAsync(lockKey, &quot;1&quot;, TimeSpan.FromSeconds(10), When.NotExists))
        {
            try
            {
                // åŒé‡æ£€æŸ¥
                cached = await _cache.GetStringAsync(cacheKey);
                if (cached != null)
                    return JsonSerializer.Deserialize&lt;Product&gt;(cached);
                
                var product = await _repository.GetByIdAsync(productId);
                if (product != null)
                {
                    await _cache.SetStringAsync(cacheKey, JsonSerializer.Serialize(product),
                        new DistributedCacheEntryOptions { AbsoluteExpirationRelativeToNow = TimeSpan.FromHours(1) });
                }
                return product;
            }
            finally
            {
                await db.KeyDeleteAsync(lockKey);
            }
        }
        
        // æœªè·å–åˆ°é”ï¼Œç­‰å¾…åé‡è¯•
        await Task.Delay(100);
        return await GetHotProductAsync(productId);
    }
}</pre>
<h4 id="è§£å†³æ–¹æ¡ˆäºŒä½¿ç”¨-fusioncacheæ¨è">è§£å†³æ–¹æ¡ˆäºŒï¼šä½¿ç”¨
FusionCacheï¼ˆæ¨èï¼‰</h4>
<pre><code class="language-csharp">// FusionCache å†…ç½®é˜²å‡»ç©¿æœºåˆ¶
builder.Services.AddFusionCache()
    .WithDefaultEntryOptions(new FusionCacheEntryOptions
    {
        Duration = TimeSpan.FromHours(1),
        // å¯ç”¨æ•…éšœå®‰å…¨æœºåˆ¶ï¼šå³ä½¿ç¼“å­˜è¿‡æœŸï¼Œä»è¿”å›æ—§æ•°æ®
        IsFailSafeEnabled = true,
        FailSafeMaxDuration = TimeSpan.FromHours(24),
        // åå°åˆ·æ–°
        FactorySoftTimeout = TimeSpan.FromMilliseconds(100)
    })
    .WithDistributedCache(
        new RedisCache(new RedisCacheOptions { Configuration = &quot;localhost:6379&quot; })
    );

// ä½¿ç”¨
public class ProductService
{
    private readonly IFusionCache _cache;
    
    public async Task&lt;Product?&gt; GetProductAsync(int id)
    {
        return await _cache.GetOrSetAsync(
            $&quot;product:{id}&quot;,
            async _ =&gt; await _repository.GetByIdAsync(id),
            TimeSpan.FromHours(1)
        );
    }
}</pre>
<h3 id="ç¼“å­˜é›ªå´©-cache-avalanche">2.3 ç¼“å­˜é›ªå´© (Cache Avalanche)</h3>
<p><strong>é—®é¢˜</strong>ï¼šå¤§é‡ Key
åŒæ—¶è¿‡æœŸï¼Œæˆ–ç¼“å­˜æœåŠ¡å®•æœºï¼Œå¯¼è‡´è¯·æ±‚å…¨éƒ¨æ¶Œå‘æ•°æ®åº“ã€‚</p>
<h4 id="è§£å†³æ–¹æ¡ˆä¸€éšæœºè¿‡æœŸæ—¶é—´">è§£å†³æ–¹æ¡ˆä¸€ï¼šéšæœºè¿‡æœŸæ—¶é—´</h4>
<pre><code class="language-csharp">public static class CacheExtensions
{
    private static readonly Random _random = new();
    
    public static async Task SetWithJitterAsync&lt;T&gt;(
        this IDistributedCache cache,
        string key,
        T value,
        TimeSpan baseDuration)
    {
        // åœ¨åŸºç¡€ TTL ä¸Šå¢åŠ éšæœºåç§»ï¼ˆ0-10åˆ†é’Ÿï¼‰
        var jitter = TimeSpan.FromMinutes(_random.Next(0, 10));
        var options = new DistributedCacheEntryOptions
        {
            AbsoluteExpirationRelativeToNow = baseDuration + jitter
        };
        
        await cache.SetStringAsync(key, JsonSerializer.Serialize(value), options);
    }
}</pre>
<h4 id="è§£å†³æ–¹æ¡ˆäºŒå¤šçº§ç¼“å­˜">è§£å†³æ–¹æ¡ˆäºŒï¼šå¤šçº§ç¼“å­˜</h4>
<pre><code class="language-csharp">public class MultiLevelCache
{
    private readonly IMemoryCache _l1Cache;  // æœ¬åœ°ç¼“å­˜
    private readonly IDistributedCache _l2Cache;  // Redis
    
    public async Task&lt;T?&gt; GetAsync&lt;T&gt;(string key) where T : class
    {
        // L1: æœ¬åœ°ç¼“å­˜
        if (_l1Cache.TryGetValue(key, out T? value))
            return value;
        
        // L2: Redis
        try
        {
            var cached = await _l2Cache.GetStringAsync(key);
            if (cached != null)
            {
                value = JsonSerializer.Deserialize&lt;T&gt;(cached);
                // å›å¡« L1ï¼ˆçŸ­è¿‡æœŸï¼‰
                _l1Cache.Set(key, value, TimeSpan.FromSeconds(30));
                return value;
            }
        }
        catch (RedisConnectionException)
        {
            // Redis ä¸å¯ç”¨ï¼Œé™çº§
        }
        
        return null;
    }
}</pre>
<h4 id="è§£å†³æ–¹æ¡ˆä¸‰ç†”æ–­é™çº§polly">è§£å†³æ–¹æ¡ˆä¸‰ï¼šç†”æ–­é™çº§ï¼ˆPollyï¼‰</h4>
<pre><code class="language-csharp">// ä½¿ç”¨ Polly å®ç°ç†”æ–­
builder.Services.AddStackExchangeRedisCache(options =&gt;
{
    options.Configuration = &quot;localhost:6379&quot;;
});

builder.Services.AddResiliencePipeline(&quot;cache-pipeline&quot;, builder =&gt;
{
    builder
        .AddCircuitBreaker(new CircuitBreakerStrategyOptions
        {
            FailureRatio = 0.5,
            SamplingDuration = TimeSpan.FromSeconds(10),
            MinimumThroughput = 10,
            BreakDuration = TimeSpan.FromSeconds(30)
        })
        .AddTimeout(TimeSpan.FromSeconds(1));
});</pre>
<h3 id="ä¸‰å¤§é—®é¢˜å¯¹æ¯”">2.4 ä¸‰å¤§é—®é¢˜å¯¹æ¯”</h3>
<table>
<thead>
<tr>
<th>é—®é¢˜</th>
<th>åŸå› </th>
<th>è§£å†³æ–¹æ¡ˆ</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ç©¿é€</strong></td>
<td>æŸ¥è¯¢ä¸å­˜åœ¨çš„æ•°æ®</td>
<td>ç¼“å­˜ç©ºå¯¹è±¡ã€å¸ƒéš†è¿‡æ»¤å™¨</td>
</tr>
<tr>
<td><strong>å‡»ç©¿</strong></td>
<td>çƒ­ç‚¹Keyè¿‡æœŸ</td>
<td>åˆ†å¸ƒå¼é”ã€FusionCache</td>
</tr>
<tr>
<td><strong>é›ªå´©</strong></td>
<td>å¤§é‡KeyåŒæ—¶è¿‡æœŸ</td>
<td>éšæœºTTLã€å¤šçº§ç¼“å­˜ã€ç†”æ–­</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="ç¼“å­˜æ›´æ–°ç­–ç•¥">3. ç¼“å­˜æ›´æ–°ç­–ç•¥</h2>
<h3 id="cache-asideæœ€å¸¸ç”¨">3.1 Cache Asideï¼ˆæœ€å¸¸ç”¨ï¼‰</h3>
<pre><code class="language-csharp">public class CacheAsideService
{
    public async Task&lt;T?&gt; GetAsync&lt;T&gt;(string key, Func&lt;Task&lt;T?&gt;&gt; factory) where T : class
    {
        // 1. å…ˆæŸ¥ç¼“å­˜
        var cached = await _cache.GetStringAsync(key);
        if (cached != null)
            return JsonSerializer.Deserialize&lt;T&gt;(cached);
        
        // 2. æŸ¥æ•°æ®åº“
        var data = await factory();
        
        // 3. å›å¡«ç¼“å­˜
        if (data != null)
        {
            await _cache.SetStringAsync(key, JsonSerializer.Serialize(data),
                new DistributedCacheEntryOptions { AbsoluteExpirationRelativeToNow = TimeSpan.FromHours(1) });
        }
        
        return data;
    }
    
    public async Task UpdateAsync&lt;T&gt;(string key, T value, Func&lt;Task&gt; updateDb)
    {
        // 1. å…ˆæ›´æ–°æ•°æ®åº“
        await updateDb();
        
        // 2. å†åˆ é™¤ç¼“å­˜ï¼ˆè€Œéæ›´æ–°ï¼‰
        await _cache.RemoveAsync(key);
    }
}</pre>
<h3 id="å»¶è¿ŸåŒåˆ ">3.2 å»¶è¿ŸåŒåˆ </h3>
<pre><code class="language-csharp">public async Task UpdateWithDelayDeleteAsync(string key, Product product)
{
    // 1. å…ˆåˆ é™¤ç¼“å­˜
    await _cache.RemoveAsync(key);
    
    // 2. æ›´æ–°æ•°æ®åº“
    await _repository.UpdateAsync(product);
    
    // 3. å»¶è¿Ÿå†åˆ ä¸€æ¬¡
    _ = Task.Run(async () =&gt;
    {
        await Task.Delay(500);
        await _cache.RemoveAsync(key);
    });
}</pre>
<h3 id="åŸºäºæ¶ˆæ¯é˜Ÿåˆ—çš„æœ€ç»ˆä¸€è‡´æ€§">3.3 åŸºäºæ¶ˆæ¯é˜Ÿåˆ—çš„æœ€ç»ˆä¸€è‡´æ€§</h3>
<pre><code class="language-csharp">// ä½¿ç”¨ MassTransit + RabbitMQ
public class ProductUpdatedConsumer : IConsumer&lt;ProductUpdated&gt;
{
    private readonly IDistributedCache _cache;
    
    public async Task Consume(ConsumeContext&lt;ProductUpdated&gt; context)
    {
        var key = $&quot;product:{context.Message.ProductId}&quot;;
        await _cache.RemoveAsync(key);
    }
}

// å‘å¸ƒäº‹ä»¶
public async Task UpdateProductAsync(Product product)
{
    await _repository.UpdateAsync(product);
    await _publishEndpoint.Publish(new ProductUpdated { ProductId = product.Id });
}</pre>
<hr />
<h2 id="ä½¿ç”¨ç¼“å­˜æ³¨æ„äº‹é¡¹">4. ä½¿ç”¨ç¼“å­˜æ³¨æ„äº‹é¡¹</h2>
<h3 id="key-è®¾è®¡è§„èŒƒ">4.1 Key è®¾è®¡è§„èŒƒ</h3>
<pre><code class="language-csharp">public static class CacheKeys
{
    // å‘½åè§„èŒƒï¼šä¸šåŠ¡å‰ç¼€:å¯¹è±¡ç±»å‹:å”¯ä¸€æ ‡è¯†[:ç‰ˆæœ¬å·]
    public static string User(int id) =&gt; $&quot;user:profile:{id}&quot;;
    public static string Product(int id) =&gt; $&quot;product:detail:{id}&quot;;
    public static string Order(string orderId) =&gt; $&quot;order:info:{orderId}&quot;;
    public static string List(string category, int page) =&gt; $&quot;list:{category}:page:{page}&quot;;
}</pre>
<p><strong>æ³¨æ„äº‹é¡¹</strong>ï¼š - âœ… ä½¿ç”¨å†’å·åˆ†éš”å±‚çº§ - âœ… Key é•¿åº¦ &lt;
200 å­—èŠ‚ - âŒ é¿å…è¿‡é•¿çš„ Key - âŒ é¿å…åŒ…å«ç”¨æˆ·è¾“å…¥ï¼ˆæ³¨å…¥é£é™©ï¼‰</p>
<h3 id="å¤§-key-å¤„ç†">4.2 å¤§ Key å¤„ç†</h3>
<pre><code class="language-csharp">// æ‹†åˆ†å¤§åˆ—è¡¨
public class BigListCache
{
    private const int PageSize = 100;
    
    public async Task SetLargeListAsync&lt;T&gt;(string key, List&lt;T&gt; items)
    {
        var pageCount = (items.Count + PageSize - 1) / PageSize;
        
        // å­˜å‚¨å…ƒæ•°æ®
        await _cache.SetStringAsync($&quot;{key}:meta&quot;, 
            JsonSerializer.Serialize(new { Total = items.Count, Pages = pageCount }));
        
        // åˆ†é¡µå­˜å‚¨
        for (int i = 0; i &lt; pageCount; i++)
        {
            var pageItems = items.Skip(i * PageSize).Take(PageSize).ToList();
            await _cache.SetStringAsync($&quot;{key}:page:{i}&quot;, JsonSerializer.Serialize(pageItems));
        }
    }
}</pre>
<h3 id="ç›‘æ§æŒ‡æ ‡">4.3 ç›‘æ§æŒ‡æ ‡</h3>
<table>
<thead>
<tr>
<th>æŒ‡æ ‡</th>
<th>å¥åº·é˜ˆå€¼</th>
<th>å‘Šè­¦é˜ˆå€¼</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>å‘½ä¸­ç‡</strong></td>
<td>&gt; 90%</td>
<td>&lt; 80%</td>
</tr>
<tr>
<td><strong>P99 å»¶è¿Ÿ</strong></td>
<td>&lt; 10ms</td>
<td>&gt; 50ms</td>
</tr>
<tr>
<td><strong>å†…å­˜ä½¿ç”¨ç‡</strong></td>
<td>&lt; 80%</td>
<td>&gt; 90%</td>
</tr>
<tr>
<td><strong>è¿æ¥æ•°</strong></td>
<td>&lt; 80% max</td>
<td>&gt; 90% max</td>
</tr>
</tbody>
</table>
<h3 id="æ·˜æ±°ç­–ç•¥">4.4 æ·˜æ±°ç­–ç•¥</h3>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr>
<th>Redis ç­–ç•¥</th>
<th>æè¿°</th>
<th>é…ç½®</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>allkeys-lru</code></td>
<td>æ·˜æ±°æœ€è¿‘æœ€å°‘ä½¿ç”¨ï¼ˆæ¨èï¼‰</td>
<td><code>maxmemory-policy allkeys-lru</code></td>
</tr>
<tr>
<td><code>allkeys-lfu</code></td>
<td>æ·˜æ±°æœ€ä¸ç»å¸¸ä½¿ç”¨</td>
<td><code>maxmemory-policy allkeys-lfu</code></td>
</tr>
<tr>
<td><code>volatile-ttl</code></td>
<td>ä¼˜å…ˆæ·˜æ±°å³å°†è¿‡æœŸ</td>
<td><code>maxmemory-policy volatile-ttl</code></td>
</tr>
</tbody>
</table>
<hr />
<h2 id="net-æœ€ä½³å®è·µ">5. .NET æœ€ä½³å®è·µ</h2>
<h3 id="ä½¿ç”¨-hybridcache.net-9">5.1 ä½¿ç”¨ HybridCacheï¼ˆ.NET 9+ï¼‰</h3>
<pre><code class="language-csharp">// .NET 9 å†…ç½®çš„æ··åˆç¼“å­˜ï¼Œè‡ªåŠ¨å¤„ç†å¤šçº§ç¼“å­˜
builder.Services.AddHybridCache(options =&gt;
{
    options.DefaultEntryOptions = new HybridCacheEntryOptions
    {
        Expiration = TimeSpan.FromHours(1),
        LocalCacheExpiration = TimeSpan.FromMinutes(5)
    };
});

public class ProductService
{
    private readonly HybridCache _cache;
    
    public async Task&lt;Product&gt; GetProductAsync(int id)
    {
        return await _cache.GetOrCreateAsync(
            $&quot;product:{id}&quot;,
            async cancel =&gt; await _repository.GetByIdAsync(id, cancel)
        );
    }
}</pre>
<h3 id="ä½¿ç”¨-fusioncacheæ¨è">5.2 ä½¿ç”¨ FusionCacheï¼ˆæ¨èï¼‰</h3>
<pre><code class="language-csharp">builder.Services.AddFusionCache()
    .WithDefaultEntryOptions(new FusionCacheEntryOptions
    {
        Duration = TimeSpan.FromHours(1),
        IsFailSafeEnabled = true,
        FailSafeMaxDuration = TimeSpan.FromDays(1),
        FactorySoftTimeout = TimeSpan.FromMilliseconds(100),
        AllowBackgroundDistributedCacheOperations = true
    })
    .WithDistributedCache(new RedisCache(new RedisCacheOptions 
    { 
        Configuration = &quot;localhost:6379&quot; 
    }))
    .WithSerializer(new FusionCacheSystemTextJsonSerializer());

// è‡ªåŠ¨å¤„ç†ï¼šå¤šçº§ç¼“å­˜ã€é˜²å‡»ç©¿ã€æ•…éšœå®‰å…¨ã€åå°åˆ·æ–°
public class ProductService
{
    private readonly IFusionCache _cache;
    
    public async Task&lt;Product?&gt; GetAsync(int id) =&gt;
        await _cache.GetOrSetAsync($&quot;product:{id}&quot;, 
            _ =&gt; _repository.GetByIdAsync(id));
    
    public async Task UpdateAsync(Product product)
    {
        await _repository.UpdateAsync(product);
        await _cache.RemoveAsync($&quot;product:{product.Id}&quot;);
    }
}</pre>
<h3 id="å®Œæ•´ç¤ºä¾‹ç”µå•†å•†å“ç¼“å­˜">5.3 å®Œæ•´ç¤ºä¾‹ï¼šç”µå•†å•†å“ç¼“å­˜</h3>
<pre><code class="language-csharp">public class ProductCacheService
{
    private readonly IFusionCache _cache;
    private readonly IProductRepository _repository;
    private readonly ILogger&lt;ProductCacheService&gt; _logger;
    
    public async Task&lt;Product?&gt; GetProductAsync(int productId)
    {
        return await _cache.GetOrSetAsync(
            CacheKeys.Product(productId),
            async ct =&gt;
            {
                _logger.LogInformation(&quot;Cache miss for product {Id}&quot;, productId);
                return await _repository.GetByIdAsync(productId, ct);
            },
            new FusionCacheEntryOptions
            {
                Duration = TimeSpan.FromHours(1),
                JitterMaxDuration = TimeSpan.FromMinutes(10), // é˜²é›ªå´©
                IsFailSafeEnabled = true,
                FailSafeMaxDuration = TimeSpan.FromHours(24)
            }
        );
    }
    
    public async Task UpdateProductAsync(Product product)
    {
        await _repository.UpdateAsync(product);
        
        // åˆ é™¤ç¼“å­˜å¹¶å‘å¸ƒå¤±æ•ˆäº‹ä»¶
        await _cache.RemoveAsync(CacheKeys.Product(product.Id));
        
        _logger.LogInformation(&quot;Product {Id} cache invalidated&quot;, product.Id);
    }
    
    public async Task&lt;List&lt;Product&gt;&gt; GetTopProductsAsync(int count)
    {
        return await _cache.GetOrSetAsync(
            $&quot;products:top:{count}&quot;,
            _ =&gt; _repository.GetTopAsync(count),
            TimeSpan.FromMinutes(10)
        ) ?? new List&lt;Product&gt;();
    }
}</pre>
<hr />
<h2 id="æ€»ç»“">6. æ€»ç»“</h2>
<h3 id="æ ¸å¿ƒè¦ç‚¹">æ ¸å¿ƒè¦ç‚¹</h3>
<table>
<colgroup>
<col style="width: 42%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr>
<th>ä¸»é¢˜</th>
<th>å…³é”®ç‚¹</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ç¼“å­˜é—®é¢˜</strong></td>
<td>ç©¿é€â†’ç©ºå¯¹è±¡/å¸ƒéš†è¿‡æ»¤å™¨ï¼Œå‡»ç©¿â†’åˆ†å¸ƒå¼é”/FusionCacheï¼Œé›ªå´©â†’éšæœºTTL/å¤šçº§ç¼“å­˜</td>
</tr>
<tr>
<td><strong>æ›´æ–°ç­–ç•¥</strong></td>
<td>Cache Asideï¼šå…ˆæ›´æ–° DBï¼Œå†åˆ é™¤ç¼“å­˜</td>
</tr>
<tr>
<td><strong>æ¨èæ–¹æ¡ˆ</strong></td>
<td>FusionCacheï¼ˆæˆç†Ÿï¼‰æˆ– HybridCacheï¼ˆ.NET 9+ï¼‰</td>
</tr>
<tr>
<td><strong>Key è®¾è®¡</strong></td>
<td><code>ä¸šåŠ¡:ç±»å‹:ID</code>ï¼Œé•¿åº¦é€‚ä¸­ï¼Œé¿å…å¤§ Key</td>
</tr>
<tr>
<td><strong>ç›‘æ§</strong></td>
<td>å‘½ä¸­ç‡ &gt; 90%ï¼ŒP99 &lt; 10ms</td>
</tr>
</tbody>
</table>
<h3 id="è®¾è®¡æ£€æŸ¥æ¸…å•">è®¾è®¡æ£€æŸ¥æ¸…å•</h3>
<ul class="task-list">
<li><label><input type="checkbox" />æ˜¯å¦å¤„ç†äº†ç¼“å­˜ç©¿é€ï¼Ÿ</label></li>
<li><label><input type="checkbox" />æ˜¯å¦å¤„ç†äº†ç¼“å­˜å‡»ç©¿ï¼Ÿ</label></li>
<li><label><input type="checkbox" />æ˜¯å¦å¤„ç†äº†ç¼“å­˜é›ªå´©ï¼Ÿ</label></li>
<li><label><input type="checkbox" />Key å‘½åæ˜¯å¦è§„èŒƒï¼Ÿ</label></li>
<li><label><input type="checkbox" />TTL æ˜¯å¦å¸¦éšæœºåç§»ï¼Ÿ</label></li>
<li><label><input type="checkbox" />æ˜¯å¦æœ‰é™çº§å…œåº•æ–¹æ¡ˆï¼Ÿ</label></li>
<li><label><input type="checkbox" />æ˜¯å¦æœ‰ç›‘æ§å‘Šè­¦ï¼Ÿ</label></li>
</ul>
<h3 id="å‚è€ƒèµ„æº">å‚è€ƒèµ„æº</h3>
<ul>
<li><a
href="https://learn.microsoft.com/en-us/aspnet/core/performance/caching">Microsoft.Extensions.Caching</a></li>
<li><a
href="https://github.com/ZiggyCreatures/FusionCache">FusionCache</a></li>
<li><a
href="https://stackexchange.github.io/StackExchange.Redis/">StackExchange.Redis</a></li>
<li><a
href="https://learn.microsoft.com/en-us/aspnet/core/performance/caching/hybrid">HybridCache
in .NET 9</a></li>
</ul>

                </article>
            </div>
        </section>

        <!-- å³ä¾§çƒ­é—¨æ–‡ç«  -->
        <aside class="popular-sidebar">
            <div class="popular-header">
                <h3>çƒ­é—¨æ–‡ç« </h3>
            </div>
            <div class="popular-list" id="popular-list">
                <!-- åŠ¨æ€ç”Ÿæˆçš„çƒ­é—¨æ–‡ç« åˆ—è¡¨ -->
            </div>
        </aside>
    </main>

    <!-- JavaScript -->
    <script type="module" src="/script.js?v=2.2.0"></script>
    
    <!-- Initialize Highlight.js -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Highlight all code blocks
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
            });
        });
    </script>
</body>
</html>