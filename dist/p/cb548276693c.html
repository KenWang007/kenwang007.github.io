<!DOCTYPE html>
<html lang="zh-CN" class="page-article">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Clawdbot 架构与安全分析 - 关键词: 架构, Clawdbot, 架构与安全分析">
    <meta name="keywords" content="架构, Clawdbot, 架构与安全分析">
    <meta name="author" content="Ken Wang">
    <meta name="robots" content="index, follow">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://kenwang007.github.io/dist/p/cb548276693c.html">
    <meta property="og:title" content="Clawdbot 架构与安全分析 - Ken的知识库">
    <meta property="og:description" content="Clawdbot 架构与安全分析 - 关键词: 架构, Clawdbot, 架构与安全分析">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary">
    <meta property="twitter:url" content="https://kenwang007.github.io/dist/p/cb548276693c.html">
    <meta property="twitter:title" content="Clawdbot 架构与安全分析 - Ken的知识库">
    <meta property="twitter:description" content="Clawdbot 架构与安全分析 - 关键词: 架构, Clawdbot, 架构与安全分析">
    
    <!-- Theme Color -->
    <meta name="theme-color" content="#6366f1">
    
    <title>Clawdbot 架构与安全分析 - Ken的知识库</title>
    <link rel="stylesheet" href="/style.css?v=2.1.2">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22 fill=%22%236366f1%22>📚</text></svg>">
    <link rel="canonical" href="https://kenwang007.github.io/dist/p/cb548276693c.html">
    <link rel="manifest" href="/manifest.json">
    
    <!-- Highlight.js for code syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="Ken的知识库 RSS Feed" href="/rss.xml">
    
    <!-- Breadcrumb Navigation -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "BreadcrumbList",
      "itemListElement": [
        {
          "@type": "ListItem",
          "position": 1,
          "name": "首页",
          "item": "https://kenwang007.github.io/"
        },
        {
          "@type": "ListItem",
          "position": 2,
          "name": "Clawdbot 架构与安全分析",
          "item": "https://kenwang007.github.io/dist/p/cb548276693c.html"
        }
      ]
    }
    </script>
    
    <!-- Article Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Article",
      "headline": "Clawdbot 架构与安全分析",
      "description": "Clawdbot 架构与安全分析 - 关键词: 架构, Clawdbot, 架构与安全分析",
      "author": {
        "@type": "Person",
        "name": "Ken Wang"
      },
      "datePublished": "2026-01-30T20:25:22.935398",
      "dateModified": "2026-01-30T20:25:22.935398",
      "inLanguage": "zh-CN"
    }
    </script>
</head>
<body>
    <!-- 星空背景 -->
    <div class="stars"></div>
    <div class="stars2"></div>
    <div class="stars3"></div>

    <!-- 顶部固定导航 -->
    <header class="top-nav">
        <div class="nav-container">
            <div class="logo">
                <a href="/index.html">
                    <span class="logo-text">📚 Ken的知识库</span>
                </a>
            </div>
            <nav class="main-nav">
                <ul id="nav-menu" class="nav-menu">
                    <!-- 动态生成的导航菜单项 -->
                </ul>
            </nav>
        </div>
    </header>

    <!-- 主内容区域 -->
    <main class="main-content">
        <!-- 左侧固定关键词索引 -->
        <aside class="keyword-sidebar">
            <div class="keyword-header">
                <h3>关键词索引</h3>
            </div>
            <div class="keyword-list" id="keyword-list">
                <!-- 动态生成的关键词 -->
            </div>
        </aside>

        <!-- 中间主内容 -->
        <section class="content-area">
            <div class="content-wrapper">
                <article class="markdown-content">
                    
<h1 id="clawdbot-架构与安全分析">Clawdbot 架构与安全分析</h1>
<h2 id="目录">目录</h2>
<ol type="1">
<li><a href="#1-clawdbot-核心架构">Clawdbot 核心架构</a></li>
<li><a
href="#2-为什么能通过命令行操作本地电脑">为什么能通过命令行操作本地电脑？</a></li>
<li><a href="#3-为什么需要-gateway-的存在">为什么需要 gateway
的存在</a></li>
<li><a href="#4-调用-llm-时的本地信息泄漏风险">调用 LLM
时的本地信息泄漏风险</a></li>
</ol>
<hr />
<h2 id="clawdbot-核心架构">1. Clawdbot 核心架构</h2>
<h3 id="整体架构图">1. 整体架构图</h3>
<pre><code>WhatsApp / Telegram / Slack / Discord / WebChat
               │
               ▼
┌───────────────────────────────┐
│         Gateway              │
│    (控制平面)             │
│     ws://127.0.0.1:18789      │
└──────────────┬────────────────┘
               │
     ├─ AI Agent (RPC 模式)
     ├─ CLI 命令行
     ├─ WebChat UI
     ├─ macOS 菜单栏应用
     └─ iOS/Android 节点</pre>
<hr />
<h3 id="为什么能通过命令行操作本地电脑">2.
为什么能通过命令行操作本地电脑？</h3>
<h4 id="核心本地运行-系统调用">核心：本地运行 + 系统调用</h4>
<p><strong>① Gateway 是本地服务</strong> - 用 Node.js 编写 - 通过
<code>launchd</code>/<code>systemd</code> 作为系统服务运行 - 监听
WebSocket 端口（默认 <code>18789</code>） -
有完整的本地文件系统访问权限</p>
<p><strong>② exec 工具的作用</strong></p>
<pre><code class="language-bash"># Clawdbot 的 exec 工具可以：
exec 命令                    # 执行任意 shell 命令
node invoke &lt;command&gt;         # 通过节点调用设备功能
system.run &lt;cmd&gt;              # 运行系统命令</pre>
<p><strong>③ macOS 特有：AppleScript</strong></p>
<pre><code class="language-applescript"># 通过 osascript 操作 macOS 原生应用
osascript -e &#39;tell application &quot;Calendar&quot; to make new event...&#39;
osascript -e &#39;tell application &quot;Reminders&quot; to make new reminder...&#39;
osascript -e &#39;tell application &quot;Finder&quot; to open...&#39;</pre>
<hr />
<h3 id="具体实现机制">3. 具体实现机制</h3>
<h4 id="在-macos-上添加提醒的流程">在 macOS 上添加提醒的流程</h4>
<pre><code class="language-bash"># 我刚才执行的命令
osascript -e &#39;tell application &quot;Reminders&quot;
    set newReminder to make new reminder 
        with properties {
            name:&quot;明天中午12点 - 午餐提醒&quot;,
            due date:date &quot;Friday, January 30, 2026 12:00:00&quot;
        }
end tell&#39;</pre>
<p><strong>这个过程：</strong> 1. Clawdbot 接收到你的消息 2. 决定使用
<code>exec</code> 工具 3. 调用 <code>osascript</code> 命令 4.
<code>osascript</code> 通过 macOS 的 Apple Events 系统与 Reminders
应用通信 5. Reminders 创建提醒并通知系统</p>
<hr />
<h3 id="不同系统的调用方式">4. 不同系统的调用方式</h3>
<table style="width:100%;">
<colgroup>
<col style="width: 16%" />
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr>
<th>操作</th>
<th>macOS 方法</th>
<th>Linux 方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>日历</td>
<td><code>osascript -e 'tell application "Calendar"'</code></td>
<td><code>dbus-send --print-reply</code></td>
<td>通过系统级 API 调用</td>
</tr>
<tr>
<td>提醒</td>
<td><code>osascript -e 'tell application "Reminders"'</code></td>
<td><code>task add</code></td>
<td>同上</td>
</tr>
<tr>
<td>浏览器</td>
<td>通过 CDP 协议控制 Chrome/Chromium</td>
<td>同左</td>
<td>远程控制浏览器</td>
</tr>
<tr>
<td>照片</td>
<td><code>camera_snap</code> 节点调用</td>
<td><code>v4l2-ctl</code></td>
<td>调用摄像头硬件</td>
</tr>
<tr>
<td>屏幕</td>
<td><code>screen_record</code></td>
<td><code>ffmpeg -f x11grab</code></td>
<td>屏幕录制</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="关键技术点">5. 关键技术点</h3>
<h4 id="websocket-控制平面">① WebSocket 控制平面</h4>
<pre><code class="language-javascript">// Gateway 和客户端通过 WS 通信
const ws = new WebSocket(&#39;ws://127.0.0.1:18789&#39;)

// 发送命令到 Gateway
ws.send(JSON.stringify({
  type: &#39;tool_call&#39;,
  tool: &#39;exec&#39;,
  args: [&#39;osascript -e &quot;...&#39;]
}))

// 接收执行结果
ws.on(&#39;message&#39;, (data) =&gt; {
  console.log(JSON.parse(data).output)
})</pre>
<h4 id="pi-agent-的-rpc-模式">② Pi Agent 的 RPC 模式</h4>
<pre><code class="language-javascript">// AI Agent 通过 RPC 协议接收工具调用
gateway.on(&#39;tool_call&#39;, async ({ tool, args }) =&gt; {
  if (tool === &#39;exec&#39;) {
    const result = await spawn(&#39;bash&#39;, args)
    return { output: result.stdout, exitCode: result.code }
  }
})</pre>
<h4 id="node-系统的权限控制">③ Node 系统的权限控制</h4>
<pre><code class="language-bash"># macOS 有 TCC (透明度与控制) 权限
# 通过 macOS 应用可以声明和请求权限
# Calendar、Reminders、通知、文件系统等</pre>
<hr />
<h3 id="为什么称为本地优先">6. 为什么称为”本地优先”？</h3>
<pre><code>传统云端 AI:
┌──────────────┐
│  云端服务器  │ ◀── 你的请求 → 云端处理 → 返回结果
└──────────────┘

Clawdbot 本地优先:
┌─────────────────┐
│  你的 Mac      │ ◀── 直接执行本地命令 → 无需上传数据
│  (本地运行)   │
└─────────────────┘</pre>
<p><strong>优势：</strong> - ✅ 数据不离开本地设备 - ✅ 响应速度快 - ✅
离线也能用（本地功能） - ✅ 完全控制自己的数据</p>
<hr />
<h3 id="实际运行示例">7. 实际运行示例</h3>
<pre><code class="language-bash"># 启动 Gateway（作为系统服务）
clawdbot gateway --port 18789

# 查看状态
clawdbot status

# 发送消息
clawdbot message send --to +1234567890 --message &quot;你好&quot;

# 在 WebChat 中对话
# 直接访问 ws://127.0.0.1:18789/webchat</pre>
<hr />
<h2 id="为什么能通过命令行操作本地电脑-1">2.
为什么能通过命令行操作本地电脑？</h2>
<p><strong>详细解释：</strong></p>
<p>通过 exec 工具 + AppleScript，Clawdbot 可以： - 读取本地文件 -
写入本地文件 - 运行任意 shell 命令 - 控制系统应用（日历、提醒、通知等）
- 浏览网页、截图、执行操作</p>
<hr />
<h2 id="为什么需要-gateway-的存在">3. 为什么需要 Gateway 的存在</h2>
<h3 id="场景-1每个客户端独立连接">场景 1：每个客户端独立连接</h3>
<pre><code>客户端 A (WebChat) ─┐
                    ├─ 直接连接 WhatsApp
客户端 B (macOS app) ├─ 直接连接 Telegram  
客户端 C (CLI)     ├─ 直接连接 Slack
客户端 D (iOS node) ─┘   ├─ 直接调用 macOS API
                          └─ 直接运行 shell 命令</pre>
<p><strong>问题：</strong> - ❌
<strong>重复代码</strong>：每个客户端都要实现相同的功能（消息收发、状态管理）
- ❌ <strong>状态不统一</strong>：CLI 发送的消息，macOS app 看不到 - ❌
<strong>工具分散</strong>：每个客户端都要实现自己的浏览器控制、文件操作
- ❌ <strong>安全风险</strong>：多个端点连接同一服务，权限控制困难 - ❌
<strong>资源浪费</strong>：每个客户端都要维护 AI Agent 运行时</p>
<hr />
<h2 id="gateway-解决了什么">Gateway 解决了什么？</h2>
<h3 id="统一控制平面">1. 统一控制平面</h3>
<pre><code class="language-javascript">// Gateway 集中管理一切
┌─────────────────────────────────────┐
│          Gateway                │
│    ws://127.0.0.1:18789          │
│                                 │
│  ┌────────────────────────┐        │
│  │  通道管理器         │        │
│  │ - 连接/断开         │        │
│  │ - 重连逻辑         │        │
│  │ - 消息队列         │        │
│  └────────────────────────┘        │
│                                 │
│  ┌────────────────────────┐        │
│  │  会话管理器         │        │
│  │ - 上下文保持         │        │
│  │ - 历史记录         │        │
│  │ - 多端同步         │        │
│  └────────────────────────┘        │
│                                 │
│  ┌────────────────────────┐        │
│  │  工具路由器         │        │
│  │ - exec、browser      │        │
│  │ - canvas、nodes      │        │
│  └────────────────────────┘        │
│                                 │
│  ┌────────────────────────┐        │
│  │  AI Agent (Pi)       │        │
│  │ - 模型调用           │        │
│  │ - 工具流式传输       │        │
│  └────────────────────────┘        │
└─────────────────────────────────────┘</pre>
<hr />
<h3 id="客户端端变成傻瓜终端">2. 客户端端变成”傻瓜终端”</h3>
<pre><code class="language-javascript">// 所有客户端只需要做一件事：连接 Gateway
class WebChat {
  constructor() {
    this.ws = new WebSocket(&#39;ws://127.0.0.1:18789/webchat&#39;)
  }  
  
  send(message) {
    this.ws.send(JSON.stringify({ type: &#39;user_message&#39;, content: message }))
  }  
  
  onMessage(data) {
    display(data.assistant_response)  // 直接显示
  }
}

class CLI {
  async main(message) {
    const ws = await connect(&#39;ws://127.0.0.1:18789&#39;)
    ws.send({ type: &#39;user_message&#39;, content: message })
    
    for await of ws.on(&#39;message&#39;) {
      if (data.type === &#39;assistant_response&#39;) {
        console.log(data.content)
        break
      }
    }
  }
}</pre>
<p><strong>优势：</strong> - ✅ <strong>极简客户端</strong>：只需要
WebSocket + UI - ✅ <strong>功能一致</strong>：所有端享受相同的功能 - ✅
<strong>自动更新</strong>：Gateway 更新，所有客户端自动受益</p>
<hr />
<h3 id="会话统一和共享">3. 会话统一和共享</h3>
<pre><code class="language-javascript">// Gateway 统一管理会话状态
Gateway 的会话管理器：
┌─────────────────────────────────────┐
│  Session State                   │
│  ┌─────────────────────────┐       │
│  │ agent:main:main      │       │
│  │ - 上下文: [过去消息]  │       │
│  │ - 用户偏好           │       │
│  │ - 工具权限           │       │
│  └─────────────────────────┘       │
│                                 │
│  多个客户端可以接入同一会话：       │
│  • WebChat                    │
│  • macOS menu bar             │
│  • CLI (继续对话)             │
└─────────────────────────────────────┘</pre>
<p><strong>没有 Gateway：</strong> - ❌ WebChat 的对话和 macOS app
完全独立 - ❌ CLI 无法继续之前的对话</p>
<p><strong>有 Gateway：</strong> - ✅ 切换设备无缝继续同一对话 - ✅
统一的上下文和记忆</p>
<hr />
<h3 id="安全和权限集中管理">4. 安全和权限集中管理</h3>
<pre><code class="language-javascript">// Gateway 集中处理所有安全问题
Gateway 安全层：
┌─────────────────────────────────────┐
│  认证管理器                       │
│  - OAuth token 管理                │
│  - API key 轮询和降级            │
│  - 模型 failover                 │
│                                  │
│  权限控制器                       │
│  - channel.allowFrom (白名单)        │
│  - dmPolicy (私信策略)            │
│  - sandbox.mode (沙箱隔离)         │
│                                  │
│  审计日志                          │
│  - 所有工具调用记录                │
│  - 敏感操作追踪                 │
└─────────────────────────────────────┘</pre>
<p><strong>没有 Gateway：</strong> - ❌ 每个客户端都要实现自己的安全逻辑
- ❌ 权限策略分散，难以统一管理 - ❌
容易出现安全漏洞（某个客户端漏了）</p>
<hr />
<h3 id="工具系统的统一调度">5. 工具系统的统一调度</h3>
<pre><code class="language-javascript">// Gateway 作为工具调度中心
工具调用流程：

1. AI Agent 分析需要什么工具
2. Agent 向 Gateway 请求：{ tool: &#39;exec&#39;, args: [...] }
3. Gateway 检查权限和安全
4. Gateway 路由到正确的执行器
5. Gateway 返回结果给 Agent
6. Agent 根据结果继续思考

示例：
┌─────────────────────────────────────┐
│          Gateway                │
│                                 │
│  Agent 请求：                    │
│  &quot;帮我打开浏览器查 GitHub&quot;       │
│        ↓                        │
│  Gateway 路由：                  │
│  ┌─────────────────────────┐     │
│  │ browser.open → CDP    │     │
│  │ snapshot              │     │
│  │ act → navigate        │     │
│  └─────────────────────────┘     │
│        ↓                        │
│  返回给 Agent：                    │
│  &quot;已打开 GitHub，页面内容如下...&quot; │
└─────────────────────────────────────┘</pre>
<p><strong>没有 Gateway：</strong> - ❌
每个客户端都要实现完整的浏览器控制 - ❌ 重复造轮子</p>
<hr />
<h2 id="总结gateway-的核心价值">总结：Gateway 的核心价值</h2>
<table>
<thead>
<tr>
<th>维度</th>
<th>无 Gateway</th>
<th>有 Gateway</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>开发复杂度</strong></td>
<td>每个端点独立实现</td>
<td>集中实现一次</td>
</tr>
<tr>
<td><strong>代码重复</strong></td>
<td>大量重复逻辑</td>
<td>DRY 原则</td>
</tr>
<tr>
<td><strong>会话同步</strong></td>
<td>完全独立</td>
<td>多端共享</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>分散管理</td>
<td>统一控制</td>
</tr>
<tr>
<td><strong>维护成本</strong></td>
<td>需同时维护 N 个客户端</td>
<td>只维护 Gateway</td>
</tr>
<tr>
<td><strong>功能一致性</strong></td>
<td>很难保证</td>
<td>天然保证</td>
</tr>
<tr>
<td><strong>扩展性</strong></td>
<td>每个都要改</td>
<td>部署 Gateway 即可</td>
</tr>
<tr>
<td><strong>新功能</strong></td>
<td>每个端都要适配</td>
<td>一次接入</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="现实例子">现实例子</h2>
<p><strong>你现在添加提醒的完整流程：</strong></p>
<pre><code>你
 └─ WebChat 发送：&quot;添加明天12点提醒&quot;
     ↓
Gateway 收到 WebSocket 消息
     ↓
Pi Agent 分析需求
     ↓
Agent 调用工具：exec(osascript -e &#39;tell application &quot;Reminders&quot;...&#39;)
     ↓
Gateway 执行 osascript 命令
     ↓
Gateway 返回结果给 Agent
     ↓
Agent 回复：&quot;✅ 已添加...&quot;
     ↓
Gateway 通过 WebSocket 推送到 WebChat 显示</pre>
<p><strong>如果没有 Gateway，这个流程会断裂！</strong></p>
<hr />
<h2
id="总结gateway-是-clawdbot-的大脑和神经中枢让所有四肢客户端协同工作">总结：Gateway
是 Clawdbot 的”大脑和神经中枢”，让所有”四肢”（客户端）协同工作！</h2>
<hr />
<h2 id="调用-llm-时的本地信息泄漏风险">4. 调用 LLM
时的本地信息泄漏风险</h2>
<h3 id="数据流向分析">1. 数据流向分析</h3>
<pre><code>本地设备                          云端 LLM API
     │                                    │
     ├─ 用户消息 ───────────────────────┤
     ├─ 对话历史 ───────────────────────┤
     ├─ 系统提示词 ───────────────────────┤
     └─ 工具执行结果 ───────────────────┤</pre>
<p><strong>这些内容都会通过 HTTPS 发送到 OpenAI/Anthropic 等云端
API。</strong></p>
<hr />
<h3 id="到底会泄漏什么">2. 到底会泄漏什么？</h3>
<h4 id="对话历史最大的风险">① 对话历史（最大的风险）</h4>
<pre><code class="language-javascript">// Gateway 会话管理器发送给 LLM 的内容
{
  &quot;messages&quot;: [
    { &quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;帮我修改 /etc/hosts&quot; },
    { &quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;好的，已执行...&quot; },
    { &quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;还有昨天我们讨论的机密计划&quot; }
  ]
}</pre>
<p><strong>风险：</strong> - 所有对话历史都会发送到云端 -
包括之前讨论的敏感信息 - 即使你”忘记”了，云端 API 记录可能还在</p>
<h4 id="系统提示词">② 系统提示词</h4>
<pre><code class="language-javascript">// AGENTS.md、SOUL.md、TOOLS.md 等文件内容
const systemPrompt = loadFile(&#39;AGENTS.md&#39;) + loadFile(&#39;SOUL.md&#39;)</pre>
<p><strong>风险：</strong> - 所有注入到 Agent 的配置都会发送给 LLM -
包括你定义的工作空间、偏好设置等</p>
<h4 id="工具执行结果">③ 工具执行结果</h4>
<pre><code class="language-javascript">// Agent 调用 exec 读取文件后
const toolResult = exec(&#39;cat /Users/jianwang/secret.txt&#39;)
// 这个结果会被发送回 LLM 用于上下文</pre>
<p><strong>风险：</strong> - 如果 Agent 读取了敏感文件，内容会出现在 LLM
的上下文中 - 即使文件本身不直接发送，但读取后的”记忆”会持续存在</p>
<hr />
<h2 id="clawdbot-的安全措施">Clawdbot 的安全措施</h2>
<p>尽管有风险，Clawdbot <strong>确实实现了多项安全机制</strong>：</p>
<h3 id="配置层面的控制">✅ ① 配置层面的控制</h3>
<pre><code class="language-json">{
  &quot;agents&quot;: {
    &quot;defaults&quot;: {
      &quot;contextTokens&quot;: 100000,  // 限制上下文大小
      &quot;session&quot;: {
        &quot;reset&quot;: {
          &quot;mode&quot;: &quot;daily&quot;  // 每天重置会话，旧历史不会累积
        }
      },
      &quot;memorySearch&quot;: {
        &quot;enabled&quot;: true  // 本地记忆搜索，不用每次重传
      }
    }
  }
}</pre>
<hr />
<h3 id="模型提供商选择">✅ ② 模型提供商选择</h3>
<pre><code class="language-bash"># 可以选择不同提供商
anthropic/claude-opus-4.5      # Anthropic 承诺不训练数据
openai/gpt-4                  # OpenAI 的隐私政策
zai/glm-4.7                    # 可能是本地/中国模型</pre>
<hr />
<h3 id="本地模型选项">✅ ③ 本地模型选项</h3>
<pre><code class="language-json">{
  &quot;models&quot;: {
    &quot;providers&quot;: {
      &quot;ollama&quot;: {  // 本地 LLM，数据不离开设备
        &quot;baseUrl&quot;: &quot;http://localhost:11434&quot;,
        &quot;apiKey&quot;: &quot;local&quot;
      }
    }
  }
}</pre>
<hr />
<h3 id="工具权限控制">✅ ④ 工具权限控制</h3>
<pre><code class="language-json">{
  &quot;tools&quot;: {
    &quot;exec&quot;: {
      &quot;ask&quot;: &quot;on-miss&quot;  // 敏感命令需要确认
      &quot;safeBins&quot;: [&quot;ls&quot;, &quot;date&quot;]  // 安全命令白名单
    }
  }
}</pre>
<hr />
<h3 id="沙箱隔离">✅ ⑤ 沙箱隔离</h3>
<pre><code class="language-json">{
  &quot;agents&quot;: {
    &quot;defaults&quot;: {
      &quot;sandbox&quot;: {
        &quot;mode&quot;: &quot;non-main&quot;  // 非 main 会话在 Docker 沙箱中运行
      }
    }
  }
}</pre>
<hr />
<h2 id="实际风险对比">实际风险对比</h2>
<table>
<thead>
<tr>
<th>风险类型</th>
<th>传统云端 ChatGPT</th>
<th>Clawdbot</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>对话历史</td>
<td>✅ 全部上传</td>
<td>✅ 全部上传</td>
<td>风险相同</td>
</tr>
<tr>
<td>工具执行结果</td>
<td>❌ 没有</td>
<td>⚠️ 会上传</td>
<td>Clawdbot 特有风险</td>
</tr>
<tr>
<td>本地文件系统</td>
<td>❌ 无法访问</td>
<td>⚠️ Agent 可读取</td>
<td>Clawdbot 特有风险</td>
</tr>
<tr>
<td>系统配置</td>
<td>❌ 不涉及</td>
<td>⚠️ 会注入到 prompt</td>
<td>Clawdbot 特有风险</td>
</tr>
<tr>
<td>数据离开设备</td>
<td>✅ 全部</td>
<td>⚠️ 部分上传</td>
<td>Clawdbot 本地操作部分不上传</td>
</tr>
</tbody>
</table>
<p><strong>关键点：</strong> - <strong>Clawdbot
的”本地优先”主要体现在工具执行（exec、file），不体现在 LLM
调用上</strong> - LLM 调用本身<strong>仍然是云端的</strong></p>
<hr />
<h2 id="网络传输安全">网络传输安全</h2>
<pre><code class="language-plaintext">你的设备                     ISP                   LLM API 服务器
     │                              │                    │
     │ ┌────────────────┐        │                    │
     │ │ HTTPS 加密    │        │                    │
     │ └────────────────┘        │                    │
     │                              │                    │
     ▼                              ▼                    │
    TLS 1.3 加密传输                │</pre>
<p><strong>安全的部分：</strong> - ✅ 传输使用 TLS 1.3 加密 - ✅
中间人无法看到内容 - ✅ 大多数 reputable API 提供商有严格的隐私政策</p>
<p><strong>可能暴露的：</strong> - ⚠️ <strong>元数据</strong>：IP
地址、请求时间、API 端点 - ⚠️
<strong>使用模式</strong>：请求频率、大致使用量 - ⚠️
<strong>模型提供商</strong>：知道你在使用哪个服务</p>
<hr />
<h2 id="如何最大程度降低风险">如何最大程度降低风险？</h2>
<h3 id="使用本地模型最佳">① 使用本地模型（最佳）</h3>
<pre><code class="language-bash"># 配置本地 Ollama
clawdbot config set models.providers.ollama.baseUrl http://localhost:11434
clawdbot config set models.providers.ollama.apiKey local

# 后所有对话都在本地完成</pre>
<hr />
<h3 id="敏感信息不要写在对话中">② 敏感信息不要写在对话中</h3>
<pre><code class="language-javascript">// ❌ 不推荐
&quot;我的密码是 abc123，帮我登录&quot;

// ✅ 推荐（通过本地工具）</pre>
<hr />
<h3 id="定期重置会话">③ 定期重置会话</h3>
<pre><code class="language-bash">clawdbot config set agents.defaults.session.reset.mode daily
# 每天清除历史，旧对话不会持续发送</pre>
<hr />
<h3 id="禁用某些工具">④ 禁用某些工具</h3>
<pre><code class="language-json">{
  &quot;tools&quot;: {
    &quot;deny&quot;: [&quot;exec&quot;, &quot;read&quot;]  // 禁止文件操作
  }
}</pre>
<hr />
<h3 id="选择隐私优先的提供商">⑤ 选择隐私优先的提供商</h3>
<pre><code class="language-bash"># Anthropic 承诺不使用客户数据训练
clawdbot config set agent.model anthropic/claude-opus-4.5</pre>
<hr />
<h2 id="总结">总结</h2>
<p><strong>是的，Clawdbot
确实存在信息泄漏风险，但需要分清：</strong></p>
<ol type="1">
<li><strong>LLM 调用层</strong>：与传统 ChatGPT
类似，对话内容会发送到云端 API</li>
<li><strong>工具执行层</strong>：额外的风险点（Agent
可以读取文件、执行命令）</li>
</ol>
<p><strong>关键认知：</strong> - ❌ <strong>“本地优先”≠
“完全离线”</strong> - ❌ <strong>“本地运行”≠ “数据不离开设备”</strong> -
✅ <strong>真正的本地安全只有：本地 LLM（Ollama/Llamafile）</strong></p>
<p><strong>建议：</strong> -
如果处理高度敏感信息，<strong>使用本地模型</strong>（Ollama） -
如果使用云端模型，<strong>避免在对话中讨论敏感话题</strong> -
<strong>定期清理历史记录</strong>（daily reset） -
<strong>理解并接受</strong>这是云端 AI 的固有特性</p>
<p><strong>Clawdbot 的价值在于给了你选择权：</strong> -
你可以用云端模型（更快、更强） - 也可以用本地模型（完全私密） -
根据场景选择合适的模式</p>
<p>这是权衡，不是完美的解决方案。🔐</p>

                </article>
            </div>
        </section>

        <!-- 右侧热门文章 -->
        <aside class="popular-sidebar">
            <div class="popular-header">
                <h3>热门文章</h3>
            </div>
            <div class="popular-list" id="popular-list">
                <!-- 动态生成的热门文章列表 -->
            </div>
        </aside>
    </main>

    <!-- JavaScript -->
    <script type="module" src="/script.js?v=2.2.0"></script>
    
    <!-- Initialize Highlight.js -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Highlight all code blocks
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
            });
        });
    </script>
</body>
</html>